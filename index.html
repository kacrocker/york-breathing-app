<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EMST 150 Trainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Tailwind configuration overrides.
        // - Use this object to add project-specific colors and fonts (e.g., 'primary').
        // - Novice tip: change these hex codes to update theme colors across the app.
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#10b981', // Emerald 500 (used for main action buttons and highlights)
                        'secondary': '#059669', // Emerald 600 (hover state)
                        'dark-bg': '#1f2937', // Gray 800 (app background)
                        'light-text': '#f9fafb', // Gray 50 (text color)
                    },
                    fontFamily: {
                        // Primary app font stack — change to any web-safe or imported font
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        
        /* Custom pulse for the timer circle */
        @keyframes pulse-ring {
            0% {
                transform: scale(0.3);
                opacity: 1;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        .timer-ring-active {
            box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4);
            animation: pulse-ring 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        /* Confetti Animation */
        @keyframes confetti-fall {
            0% { 
                transform: translateY(-100vh) rotate(0deg); 
                opacity: 1; 
            }
            100% { 
                transform: translateY(100vh) rotate(720deg); 
                opacity: 0; 
            }
        }

        .confetti {
            position: absolute;
            /* Start above the viewport so translateY animation clearly moves particles into view */
            top: -10vh;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            opacity: 0;
            /* Use the confetti-fall keyframes, run each particle once, and keep final state until removed */
            animation-name: confetti-fall;
            animation-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1);
            animation-iteration-count: 1;
            animation-fill-mode: forwards;
            z-index: 1000;
            will-change: transform, opacity;
            pointer-events: none;
        }

        /* Progress ring styles */
        /* Ensure strokes use inherited color from Tailwind text-* classes (do not force transparent) */
        #progress-ring { color: inherit; }
        #progress-ring .phase-arc { transition: d 220ms linear, stroke 220ms linear; stroke-linecap: round; }
        #progress-ring .sweep-dot, #progress-ring line { transition: transform 120ms linear, stroke 120ms linear, fill 120ms linear; }
        #progress-ring .sweep-dot { transform-origin: 50% 50%; }
        
        /* Make sure SVG inherits Tailwind color classes (text-*) for stroke via currentColor */
        #progress-ring svg, #progress-ring * { vector-effect: non-scaling-stroke; }
        
        /* Ensure ticks are slightly translucent */
        #progress-ring #phase-ticks line { opacity: 0.9; }
    </style>
</head>
<body class="bg-dark-bg font-sans text-light-text flex items-center justify-center p-4 min-h-screen">
    
    <!-- Confetti Container (Fixed and hidden by default) -->
    <!-- Visual element: This container holds animated 'confetti' particles generated by JavaScript.
         Keep the id `confetti-container` if you change placement or styling because JS looks it up.
         Tip: Adjust CONFETTI_COLORS or particle count in showCelebration() to change the effect. -->
    <div id="confetti-container" class="fixed inset-0 pointer-events-none z-50 overflow-hidden"></div>

    <!-- App Root: contains two main "screens":
         - `#setup-screen`: visible at load; where you pick durations and start the session
         - `#workout-screen`: hidden at load; shows the timer, controls, and set progress
         You can toggle visibility by adding/removing the 'hidden' class on these elements. -->
    <div id="app" class="w-full max-w-lg bg-gray-700 p-6 sm:p-8 rounded-xl shadow-2xl transition-all duration-300">
        <!-- Permanent Header -->
        <h1 class="text-3xl font-bold text-center text-primary mb-2">
            <span class="sm:hidden">York Timer</span>
            <span class="hidden sm:inline">York Breathing Exercise Timer</span>
        </h1>
        <p class="text-center text-sm text-gray-400 mb-6 hidden sm:block">for use with an EMST 75/150 Trainer</p>

        <!-- SETUP SCREEN (VISIBLE ON LOAD) -->
        <div id="setup-screen" class="flex flex-col items-center justify-center space-y-6">
            
            <!-- Instructions and Duration Selector -->
            <div id="rest-duration-selector" class="w-full p-4 bg-gray-800 rounded-lg text-sm text-gray-300 border-l-4 border-gray-600">
                <label class="block text-md font-semibold text-gray-100 mb-2">Select Rest Phase Duration:</label>
                <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-6">
                    <div class="flex-1 bg-primary text-white rounded-lg p-3 cursor-pointer text-center font-bold transition-colors duration-200 shadow-md border-2 border-primary"
                         id="btn-duration-15" onclick="handleRestDurationChange('15')">
                        15 seconds
                    </div>
                    <div class="flex-1 bg-gray-600 text-gray-300 rounded-lg p-3 cursor-pointer text-center font-bold transition-colors duration-200 shadow-md border-2 border-transparent hover:border-gray-500"
                         id="btn-duration-30" onclick="handleRestDurationChange('30')">
                        30 seconds
                    </div>
                </div>
            </div>
            
            <!-- Initial Instruction Message -->
            <div class="text-center w-full">
                 <div id="initial-instruction-text" class="text-base font-semibold text-gray-300 sm:mb-2 px-4">
                    Please make sure your sound is ON and the volume is turned up. Then press "Start Session" to begin. Focus on inhaling deeply and exhaling forcefully and quickly against the device's resistance.
                 </div>
            </div>
            
            <!-- Start Session Button (Triggers transition to workout) -->
            <button id="start-button" 
                    class="px-6 py-3 text-lg font-semibold rounded-lg bg-primary hover:bg-secondary text-light-text transition-all duration-200 shadow-md hover:shadow-lg focus:outline-none focus:ring-4 focus:ring-primary focus:ring-opacity-50 w-full max-w-xs sm:max-w-none">
                Start Session
            </button>
        </div>

        <!-- WORKOUT SCREEN (HIDDEN ON LOAD) -->
        <div id="workout-screen" class="hidden">
            
            <!-- Status Display (Handles all messages and instructions) -->
            <div class="text-center mb-4">
                <!-- Phase labels row: shows Inhale / Exhale / Rest with colors; current is bold -->
                <div id="phase-labels" class="mb-2 flex items-center justify-center gap-4"></div>
                <div id="status-text" class="text-3xl font-extrabold mb-2 h-10 text-white flex items-center justify-center transition-colors duration-300">Ready</div>
            </div>

            <!-- Timer & Controls Wrapper (New Responsive Block) -->
            <div class="flex flex-col sm:flex-row sm:justify-around sm:items-center mb-10">

                <!-- Timer Display (The big circle) - Left side on desktop, top on mobile -->
                <div id="timer-display-container" class="relative flex items-center justify-center h-40 w-40 sm:h-56 sm:w-56 mx-auto sm:mx-0">
                    <!-- Pulse Ring (only visible when active) -->
                    <div id="pulse-ring" class="absolute h-full w-full rounded-full bg-primary opacity-30 hidden"></div>

                    <!-- Progress Ring SVG (visual progress + arcs + sweep) -->
                    <svg id="progress-ring" viewBox="0 0 100 100" class="absolute inset-0 w-full h-full pointer-events-none z-20">
                        <!-- Background faint ring -->
                        <circle cx="50" cy="50" r="44" class="ring-bg text-gray-600" stroke="currentColor" stroke-width="4" fill="none" />
                        <!-- Phase arcs will be drawn into this group by JS -->
                        <g id="phase-arcs"></g>
                        <!-- Tick marks for subphase boundaries -->
                        <g id="phase-ticks"></g>
                        <!-- Sweep indicator group (rotated around center) -->
                        <g id="sweep-group">
                            <line x1="50" y1="6" x2="50" y2="14" stroke="currentColor" stroke-width="2" stroke-linecap="round" class="text-gray-300"/>
                            <circle cx="50" cy="12" r="2.6" class="sweep-dot text-gray-300" fill="currentColor" />
                        </g>
                    </svg>
                    
                    <!-- Main Timer Circle -->
                    <div class="relative flex flex-col items-center justify-center h-full w-full rounded-full bg-gray-800 border-4 border-gray-600 shadow-inner-xl transition-all duration-300">
                        <span id="timer-value" class="text-5xl sm:text-7xl font-mono font-bold text-primary transition-colors duration-300">0</span>
                        <span class="text-sm font-medium text-gray-400 mt-2">seconds</span>
                    </div>
                </div>

                <!-- Controls (responsive):
                     - Mobile (default): controls appear in a single row beneath the timer
                     - Desktop (sm and up): controls stack vertically to the right of the timer
                     - When the round timer is hidden (success), JS will add `mx-auto` so the controls are centered
                -->
                <div id="controls-wrapper" class="mt-4 sm:mt-0 flex flex-row items-center justify-center gap-3 w-full sm:flex-col sm:justify-center sm:space-y-4 sm:w-1/3 sm:min-w-max">
                    
                    <!-- Dynamic Active/Paused Controls -->
                    <div id="active-controls" class="flex flex-row items-center gap-3 sm:flex-col sm:space-y-4">
                        <button id="pause-resume-button" 
                                class="px-6 py-3 text-lg font-semibold rounded-lg bg-red-600 hover:bg-red-700 text-light-text transition-all duration-200 shadow-md hover:shadow-lg focus:outline-none focus:ring-4 focus:ring-red-600 focus:ring-opacity-50 w-auto sm:w-full">
                            Pause
                        </button>
                        <button id="reset-button" 
                                class="px-6 py-3 text-lg font-semibold rounded-lg bg-gray-500 hover:bg-gray-600 text-light-text transition-all duration-200 shadow-md hover:shadow-lg focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-50 w-auto sm:w-full">
                            Reset
                        </button>
                    </div>

                    <!-- New Session button: hidden by default and shown only when the session completes -->
                    <div class="mt-0 sm:mt-4 flex justify-center">
                        <button id="new-session-button" class="hidden px-6 py-3 text-lg font-semibold rounded-lg bg-primary hover:bg-secondary text-light-text transition-all duration-200 shadow-md hover:shadow-lg focus:outline-none focus:ring-4 focus:ring-primary focus:ring-opacity-50 w-auto sm:w-full max-w-xs">
                            New Session
                        </button>
                    </div>
                </div>
            </div>

            <!-- Set Progress Status Boxes -->
            <div class="mt-4 sm:mt-2 pt-4 border-t border-gray-600">
                <h3 class="text-lg font-semibold text-gray-300 mb-4 text-center">
                    <span class="sm:hidden">Set Progress</span>
                    <span class="hidden sm:inline">Set Progress (Breathes Completed)</span>
                </h3>
                <div id="set-progress-container" class="grid grid-cols-5 gap-3">
                    
                    <!-- Set Box 1 -->
                    <div id="set-box-1" class="set-box p-1 rounded-lg text-center bg-gray-500 transition-colors duration-300 shadow-xl">
                        <div class="text-xs font-medium text-light-text opacity-70">Set 1</div>
                        <!--
                            Count row: wraps the numeric counter and the checkmark so the checkmark appears
                            directly to the right of the number when a set is completed.
                        -->
                        <div class="count-row mt-1 flex items-center justify-center">
                            <div class="set-rep-counter text-lg font-bold text-light-text">0</div>
                            <div class="checkmark-container hidden ml-2 inline-flex items-center" aria-hidden="true">
                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path>
                                </svg>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Set Box 2 -->
                    <div id="set-box-2" class="set-box p-1 rounded-lg text-center bg-gray-500 transition-colors duration-300 shadow-xl">
                        <div class="text-xs font-medium text-light-text opacity-70">Set 2</div>
                        <div class="count-row mt-1 flex items-center justify-center">
                            <div class="set-rep-counter text-lg font-bold text-light-text">0</div>
                            <div class="checkmark-container hidden ml-2 inline-flex items-center" aria-hidden="true">
                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path>
                                </svg>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Set Box 3 -->
                    <div id="set-box-3" class="set-box p-1 rounded-lg text-center bg-gray-500 transition-colors duration-300 shadow-xl">
                        <div class="text-xs font-medium text-light-text opacity-70">Set 3</div>
                        <div class="count-row mt-1 flex items-center justify-center">
                            <div class="set-rep-counter text-lg font-bold text-light-text">0</div>
                            <div class="checkmark-container hidden ml-2 inline-flex items-center" aria-hidden="true">
                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path>
                                </svg>
                            </div>
                        </div>
                    </div>

                    <!-- Set Box 4 -->
                    <div id="set-box-4" class="set-box p-1 rounded-lg text-center bg-gray-500 transition-colors duration-300 shadow-xl">
                        <div class="text-xs font-medium text-light-text opacity-70">Set 4</div>
                        <div class="count-row mt-1 flex items-center justify-center">
                            <div class="set-rep-counter text-lg font-bold text-light-text">0</div>
                            <div class="checkmark-container hidden ml-2 inline-flex items-center" aria-hidden="true">
                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path>
                                </svg>
                            </div>
                        </div>
                    </div>

                    <!-- Set Box 5 -->
                    <div id="set-box-5" class="set-box p-1 rounded-lg text-center bg-gray-500 transition-colors duration-300 shadow-xl">
                        <div class="text-xs font-medium text-light-text opacity-70">Set 5</div>
                        <div class="count-row mt-1 flex items-center justify-center">
                            <div class="set-rep-counter text-lg font-bold text-light-text">0</div>
                            <div class="checkmark-container hidden ml-2 inline-flex items-center" aria-hidden="true">
                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Total Time Remaining Display (HIDDEN) -->
            <div class="mt-4 pb-2 text-center text-sm font-medium text-gray-400 hidden">
                <span id="total-time-label">Time Remaining:</span>
                <span id="total-time-value" class="ml-2 text-white font-bold">00:00</span>
            </div>
            
        </div>
    </div>

    <!-- Confirmation Modal HTML -->
    <div id="reset-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black bg-opacity-75 transition-opacity duration-300" aria-labelledby="modal-title" role="dialog" aria-modal="true">
        <div class="bg-gray-700 rounded-xl p-6 w-11/12 max-w-sm shadow-2xl transform transition-all">
            <div class="flex flex-col items-center">
                <div class="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-red-100">
                    <!-- Icon for confirmation - using simple SVG cross -->
                    <svg class="h-6 w-6 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.332 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                </div>
                <div class="mt-3 text-center">
                    <h3 class="text-lg leading-6 font-medium text-light-text" id="modal-title">Reset Session?</h3>
                    <div class="mt-2">
                        <p class="text-sm text-gray-300">
                            Are you sure you want to **Reset** this exercise session? All progress will be lost.
                        </p>
                    </div>
                </div>
            </div>
            <div class="mt-5 sm:mt-6 sm:grid sm:grid-flow-row-dense sm:grid-cols-2 sm:gap-3">
                <button type="button" id="confirm-reset" 
                        class="inline-flex w-full justify-center rounded-lg border border-transparent bg-red-600 px-4 py-2 text-base font-medium text-light-text shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 sm:col-start-2 sm:text-sm transition-colors duration-200">
                    Yes, Reset
                </button>
                <button type="button" id="cancel-reset"
                        class="mt-3 inline-flex w-full justify-center rounded-lg border border-gray-600 bg-gray-600 px-4 py-2 text-base font-medium text-light-text shadow-sm hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 sm:col-start-1 sm:mt-0 sm:text-sm transition-colors duration-200">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase variables (may be provided by host environment). Not required to run the timer locally.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        /*
         * App architecture (high level, for beginners):
         * - The UI has two screens (`#setup-screen` and `#workout-screen`) that are shown/hidden.
         * - The timer is implemented as a simple state machine using `TIMER_STATE`.
         * - Each active rep is internally divided into `SUB_PHASE`s (Inhale, Exhale, Rest) which control
         *   the on-screen instructions and sounds.
         * - Timing constants near the top (e.g., LONG_BREAK_DURATION_MS) control session length.
         * - To change core behavior (number of sets, reps, or break length), edit the constants below.
         */
        // --- Timer State and Constants ---
        const TIMER_STATE = {
            IDLE: 'IDLE',             // Not running, waiting to start
            PAUSED: 'PAUSED',         // Session temporarily paused
            ACTIVE_REP: 'ACTIVE_REP', // Currently in a rep (15s or 30s block)
            LONG_BREAK: 'LONG_BREAK', // Long rest between sets (approx 56s)
        };
        
        // SUB_PHASE names are friendly labels shown in the status area (and used to pick colors/sounds)
        const SUB_PHASE = {
            INHALE: 'Inhale Deeply',
            EXHALE: 'Exhale Forcefully',
            REST: 'Rest & Recover',
        };
        
        // --- Session configuration (easy to tweak) ---
        const TOTAL_REPS = 25; // Default total reps in a session (5 sets × 5 reps)
        const NUM_LONG_BREAKS = 4; // Long breaks happen after set 1..4
        const LONG_BREAK_DURATION_MS = 56000; // Long break length in milliseconds — change this to modify break time
        const PARTIAL_REP_DURATION_MS = 3000; // Short partial rep used at the very end of session

        // User-facing instructional text (easy to edit)
        const INITIAL_INSTRUCTIONS = "Please make sure your sound is ON and the volume is turned up. Then press \"Start Session\" to begin. Focus on inhaling deeply and exhaling forcefully and quickly against the device's resistance.";
        const EXHALE_INSTRUCTIONS = 'Exhale Quickly';
        const PAUSE_INSTRUCTIONS = "Session Paused.<br>Click 'Resume' to Continue.";

        // Phase duration map: controls how many milliseconds each top-level state lasts
        const PHASE_DURATIONS_MS = {
            [TIMER_STATE.ACTIVE_REP]: 15000,  // Default: 15 seconds total (1s Inhale + 2s Exhale + 12s Rest)
            [TIMER_STATE.LONG_BREAK]: 56000    // Long break duration - 56 seconds, reduced from 60 
        };

        // Internal variables that can change while the user interacts
        let currentRepDurationMs = 15000;          // currently selected rep length (ms)
        let currentRestLabel = 'Rest & Recover';   // label shown during the rest subphase
        let totalSessionDurationMs = 0;            // computed total session duration
        let selectedDuration = '15';               // '15' or '30' — used by UI buttons

        // Color classes used for the main status area — change these if you want different colors
        const PHASE_COLOR_CLASS = {
            [SUB_PHASE.INHALE]: 'text-cyan-400',
            [SUB_PHASE.EXHALE]: 'text-red-500',
            [SUB_PHASE.REST]: 'text-white',
            [TIMER_STATE.LONG_BREAK]: 'text-yellow-400',
            [TIMER_STATE.PAUSED]: 'text-yellow-500',
            [TIMER_STATE.IDLE]: 'text-white'
        };
        
        // Confetti colors for the celebration effect. Edit to change party colors.
        const CONFETTI_COLORS = ['#f9fafb', '#10b981', '#f59e0b', '#ef4444', '#3b82f6']; // White, Emerald, Amber, Red, Blue

        // Mutable runtime state (updated by the state machine)
        let currentState = TIMER_STATE.IDLE;
        let animationFrameId = null;                 // used by requestAnimationFrame loop
        let repCount = 0;                            // total reps completed so far (max TOTAL_REPS)
        let phaseStartTime = 0;                      // timestamp when the current phase started
        let sessionStartTime = 0;                    // timestamp when the session started
        let timeRemainingWhenPaused = 0;             // remaining ms in current phase when paused
        let sessionTimeRemainingWhenPaused = 0;      // remaining total session time while paused
        let setProgress = [0, 0, 0, 0, 0];           // counts for each of the 5 sets displayed in UI
        // activeStateBeforePause will hold ACTIVE_REP or LONG_BREAK so we can resume correctly
        let activeStateBeforePause = TIMER_STATE.ACTIVE_REP;
        let wasRunningBeforeModal = false;           // helper for the reset confirmation modal
        
        // --- Wake Lock Variables (keeps screen awake while session runs) ---
        let wakeLockSentinel = null;


        // DOM Elements
        const startScreen = document.getElementById('setup-screen');
        const workoutScreen = document.getElementById('workout-screen');
        const startButton = document.getElementById('start-button');
        const activeControls = document.getElementById('active-controls');
        const pauseResumeButton = document.getElementById('pause-resume-button');
        const resetButton = document.getElementById('reset-button');
        const statusText = document.getElementById('status-text');
        const phaseLabels = document.getElementById('phase-labels');
        const timerValue = document.getElementById('timer-value');
        const pulseRing = document.getElementById('pulse-ring');
        const timerContainer = document.getElementById('timer-display-container').querySelector('.relative.flex.flex-col');
        const setBoxes = document.querySelectorAll('.set-box');
        const totalTimeValue = document.getElementById('total-time-value');
        const confettiContainer = document.getElementById('confetti-container');
        const btnDuration15 = document.getElementById('btn-duration-15');
        const btnDuration30 = document.getElementById('btn-duration-30');

        // --- Progress Ring Initialization & Helpers ---
        const progressRing = document.getElementById('progress-ring');
        const phaseArcsGroup = progressRing ? progressRing.querySelector('#phase-arcs') : null;
        const phaseTicksGroup = progressRing ? progressRing.querySelector('#phase-ticks') : null;
        const sweepGroup = progressRing ? progressRing.querySelector('#sweep-group') : null;

        const R = 44; // radius used in SVG coordinates

        const polarToCartesian = (cx, cy, radius, angleDeg) => {
            const angleRad = (angleDeg - 90) * Math.PI / 180.0;
            return { x: cx + (radius * Math.cos(angleRad)), y: cy + (radius * Math.sin(angleRad)) };
        };

        const describeArc = (cx, cy, radius, startAngle, endAngle) => {
            const start = polarToCartesian(cx, cy, radius, endAngle);
            const end = polarToCartesian(cx, cy, radius, startAngle);
            const largeArcFlag = (endAngle - startAngle) <= 180 ? '0' : '1';
            return `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${end.x} ${end.y}`;
        };

        const clearGroup = (group) => { while (group && group.firstChild) group.removeChild(group.firstChild); };

        const setPhaseArcs = (segments) => {
            if (!phaseArcsGroup) return;
            clearGroup(phaseArcsGroup);
            clearGroup(phaseTicksGroup);
            const total = segments.reduce((s, seg) => s + seg.ms, 0);
            let angle = 0;
            segments.forEach((seg) => {
                const fraction = (total === 0) ? 0 : seg.ms / total;
                const sweep = fraction * 360;

                // If this segment covers the full circle, draw a circle element instead of an arc path
                if (sweep >= 359.999) {
                    const circ = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circ.setAttribute('cx', '50');
                    circ.setAttribute('cy', '50');
                    circ.setAttribute('r', String(R));
                    circ.setAttribute('stroke', 'currentColor');
                    circ.setAttribute('stroke-width', '6');
                    circ.setAttribute('fill', 'none');
                    circ.classList.add('phase-arc');
                    if (seg.className) circ.classList.add(seg.className);
                    phaseArcsGroup.appendChild(circ);
                } else {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', describeArc(50, 50, R, angle, angle + sweep));
                    path.setAttribute('stroke', 'currentColor');
                    path.setAttribute('stroke-width', '6');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-linecap', 'butt');
                    path.classList.add('phase-arc');
                    if (seg.className) path.classList.add(seg.className);
                    phaseArcsGroup.appendChild(path);
                }

                // Tick mark at the end of this segment
                const tickAngle = angle + sweep;
                const tickStart = polarToCartesian(50, 50, R - 6, tickAngle);
                const tickEnd = polarToCartesian(50, 50, R - 2, tickAngle);
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', tickStart.x);
                tick.setAttribute('y1', tickStart.y);
                tick.setAttribute('x2', tickEnd.x);
                tick.setAttribute('y2', tickEnd.y);
                tick.setAttribute('stroke', 'currentColor');
                tick.setAttribute('stroke-width', '2');
                if (seg.className) tick.classList.add(seg.className);
                phaseTicksGroup.appendChild(tick);

                angle += sweep;
            });
        };

        const updateSweep = (elapsedMs, durationMs) => {
            if (!sweepGroup) return;
            const frac = Math.max(0, Math.min(1, elapsedMs / durationMs));
            const angle = frac * 360;
            // Rotate directly so angle=0 is at 12 o'clock (top)
            sweepGroup.setAttribute('transform', `rotate(${angle} 50 50)`);
        };

        const setSweepColorClass = (className) => {
            if (!sweepGroup) return;
            const elems = sweepGroup.querySelectorAll('line, circle');
            elems.forEach(el => {
                // Remove any existing Tailwind text- classes (simple heuristic)
                el.className.baseVal = el.className.baseVal.split(/\s+/).filter(c => !c.startsWith('text-')).join(' ');
                if (className) el.classList.add(className);
            });
        };

        const updateProgressRing = (state, elapsedMs, durationMs) => {
            if (!progressRing) return;
            if (state === TIMER_STATE.ACTIVE_REP) {
                const inhaleMs = 1000;
                const exhaleMs = 2000;
                const restMs = Math.max(0, PHASE_DURATIONS_MS[TIMER_STATE.ACTIVE_REP] - (inhaleMs + exhaleMs));
                const segments = [
                    { name: 'inhale', ms: inhaleMs, className: PHASE_COLOR_CLASS[SUB_PHASE.INHALE] },
                    { name: 'exhale', ms: exhaleMs, className: PHASE_COLOR_CLASS[SUB_PHASE.EXHALE] },
                    { name: 'rest', ms: restMs, className: PHASE_COLOR_CLASS[SUB_PHASE.REST] },
                ];
                setPhaseArcs(segments);
                updateSweep(elapsedMs, PHASE_DURATIONS_MS[TIMER_STATE.ACTIVE_REP]);
                // Color the sweep indicator to match the current subphase
                try {
                    const pos = elapsedMs;
                    let currentClass = null;
                    if (pos < inhaleMs) currentClass = PHASE_COLOR_CLASS[SUB_PHASE.INHALE];
                    else if (pos < inhaleMs + exhaleMs) currentClass = PHASE_COLOR_CLASS[SUB_PHASE.EXHALE];
                    else currentClass = PHASE_COLOR_CLASS[SUB_PHASE.REST];
                    setSweepColorClass(currentClass);
                } catch (e) { /* ignore */ }
            } else if (state === TIMER_STATE.LONG_BREAK) {
                const segments = [{ name: 'long', ms: PHASE_DURATIONS_MS[TIMER_STATE.LONG_BREAK], className: PHASE_COLOR_CLASS[TIMER_STATE.LONG_BREAK] }];
                setPhaseArcs(segments);
                updateSweep(elapsedMs, PHASE_DURATIONS_MS[TIMER_STATE.LONG_BREAK]);
                setSweepColorClass(PHASE_COLOR_CLASS[TIMER_STATE.LONG_BREAK]);
            } else {
                // Paused / Idle: faint single ring, sweep at top
                const segments = [{ name: 'idle', ms: 1, className: 'text-gray-600' }];
                setPhaseArcs(segments);
                updateSweep(0, 1);
                setSweepColorClass('text-gray-600');
            }
        };


        // MODAL ELEMENTS
        const resetModal = document.getElementById('reset-modal');
        const confirmResetButton = document.getElementById('confirm-reset');
        const cancelResetButton = document.getElementById('cancel-reset'); 
        
        let audioContext;
        
        // --- Wake Lock Functions ---
        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    wakeLockSentinel = await navigator.wakeLock.request('screen');
                    wakeLockSentinel.addEventListener('release', () => {
                        // The wake lock was released (e.g., app moved to background)
                        // If the timer is still active, try to re-request it when the user returns
                        if (currentState !== TIMER_STATE.IDLE && currentState !== TIMER_STATE.PAUSED) {
                            requestWakeLock();
                        }
                    });
                } catch (err) {
                    // FIX: Suppress NotAllowedError as it's often due to environment/iframe restrictions.
                    if (err.name !== 'NotAllowedError') {
                         console.error(`Wake Lock request failed: ${err.name}, ${err.message}`);
                    }
                }
            }
        };

        const releaseWakeLock = () => {
            if (wakeLockSentinel !== null) {
                wakeLockSentinel.release();
                wakeLockSentinel = null;
            }
        };

        // --- Helper Functions ---
        
        /** Formats milliseconds into M:SS string. */
        const formatTime = (ms) => {
            if (ms <= 0) return '0:00';
            
            const totalSeconds = Math.ceil(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            
            const pad = (num) => num.toString().padStart(2, '0');
            
            return `${pad(minutes)}:${pad(seconds)}`;
        };

        // Short labels used for the phase label row above the timer
        const SHORT_PHASE_LABEL = {
            [SUB_PHASE.INHALE]: 'Inhale',
            [SUB_PHASE.EXHALE]: 'Exhale',
            [SUB_PHASE.REST]: 'Rest',
        };

        const renderPhaseLabels = (currentSubPhase) => {
            if (!phaseLabels) return;
            // Only render labels while in an ACTIVE_REP
            if (currentState !== TIMER_STATE.ACTIVE_REP) {
                phaseLabels.innerHTML = '';
                return;
            }

            const phases = [SUB_PHASE.INHALE, SUB_PHASE.EXHALE, SUB_PHASE.REST];
            phaseLabels.innerHTML = phases.map((p) => {
                const colorClass = PHASE_COLOR_CLASS[p] || 'text-white';
                const weightClass = (p === currentSubPhase) ? 'font-extrabold' : 'font-normal';
                const label = SHORT_PHASE_LABEL[p] || p.split(' ')[0];
                // small responsive sizes
                return `<span class="${colorClass} ${weightClass} text-lg sm:text-2xl mx-2">${label}</span>`;
            }).join('');
        };

        const hidePhaseLabels = () => { if (phaseLabels) phaseLabels.innerHTML = ''; };


        /**
         * Calculates the total session duration from the rep duration.
         * For beginners: the math here adds together the time for the main full reps,
         * the scheduled long breaks, and a small fixed amount for partial end reps.
         * Change the constants (FULL_REPS, PARTIAL_REPS_MS) if you want to alter session structure.
         */
        const calculateTotalDuration = (repDurationMs) => {
            // Full reps in the session (default 20 full reps + 5 partials spread across sets)
            const FULL_REPS = 20; 
            // The app uses 5 short partial exhale breaths totaling 15 seconds
            const PARTIAL_REPS_MS = 5 * 3000; // 5 × 3s
            // Long breaks total duration (4 breaks, each LONG_BREAK_DURATION_MS long)
            const FIXED_BREAK_MS = 4 * LONG_BREAK_DURATION_MS; 

            totalSessionDurationMs = (FULL_REPS * repDurationMs) + FIXED_BREAK_MS + PARTIAL_REPS_MS;
        };
        
        /**
         * Generates and animates a burst of confetti.
         * Beginner notes:
         * - The particle count (150), sizes, colors, and animation durations can be tweaked here.
         * - The `CONFETTI_COLORS` array above controls which colors are used.
         */
        const showCelebration = () => {
            // Clear existing confetti
            confettiContainer.innerHTML = '';
            
            // Generate 150 particles (change this number to make the effect denser or lighter)
            for (let i = 0; i < 150; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                
                // Random position, color, size, and delay
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.backgroundColor = CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)];
                // Make confetti particles bigger: base size 10px, random additional up to 10px
                confetti.style.width = `${Math.random() * 10 + 10}px`; 
                confetti.style.height = confetti.style.width;
                // Make confetti fall slower for more visibility and longer duration
                confetti.style.animationDuration = `${Math.random() * 4 + 3}s`; // 5s to 9s duration
                confetti.style.animationDelay = `${Math.random() * 0.8}s`; // Slightly longer delay spread
                confetti.style.opacity = 1;
                
                confettiContainer.appendChild(confetti);
            }
            
            // Hide and clear confetti after the maximum animation duration (e.g., 9 seconds max + a buffer)
            setTimeout(() => {
                confettiContainer.innerHTML = '';
            }, 10000); // 10 seconds total to ensure all animations complete
        };


        /** Sets the content and adjusts the font size of the main status display. */
        const setStatusText = (text, phase) => {
            statusText.innerHTML = text;
            
            // Determine color class: use phase color if available, otherwise default to white
            const colorClass = PHASE_COLOR_CLASS[phase] || PHASE_COLOR_CLASS[TIMER_STATE.IDLE];
            statusText.className = `font-extrabold mb-2 h-10 flex items-center justify-center transition-colors duration-300 ${colorClass}`; 

            // Adjust font size based on content length or line breaks
            if (text.length > 25 || text.includes('<br>')) {
                // For long messages/instructions/breaks
                statusText.classList.add('text-lg', 'font-semibold'); 
                statusText.classList.remove('text-2xl'); 
            } else {
                // For short phase names (e.g., Inhale Deeply, Paused, Ready)
                statusText.classList.add('text-2xl'); 
                statusText.classList.remove('text-lg', 'font-semibold'); 
            }
        };

        // --- Modal Functions ---
        const openResetModal = () => {
            resetModal.classList.remove('hidden');
            resetModal.classList.add('flex');
        };

        const closeResetModal = () => {
            resetModal.classList.add('hidden');
            resetModal.classList.remove('flex');
        };

        const updateDurationButtons = (value) => {
            if (value === '15') {
                btnDuration15.classList.add('bg-primary', 'text-white', 'border-primary');
                btnDuration15.classList.remove('bg-gray-600', 'text-gray-300', 'border-transparent', 'hover:border-gray-500');
                
                btnDuration30.classList.add('bg-gray-600', 'text-gray-300', 'border-transparent', 'hover:border-gray-500');
                btnDuration30.classList.remove('bg-primary', 'text-white', 'border-primary');
            } else {
                btnDuration30.classList.add('bg-primary', 'text-white', 'border-primary');
                btnDuration30.classList.remove('bg-gray-600', 'text-gray-300', 'border-transparent', 'hover:border-gray-500');
                
                btnDuration15.classList.add('bg-gray-600', 'text-gray-300', 'border-transparent', 'hover:border-gray-500');
                btnDuration15.classList.remove('bg-primary', 'text-white', 'border-primary');
            }
        };

        // --- Duration Handler Function ---
        window.handleRestDurationChange = (value) => {
            selectedDuration = value;
            updateDurationButtons(value); // Update UI visuals

            let newDurationMs;
            let newLabel;

            if (value === '30') {
                newDurationMs = 30000; // 1s Inhale + 2s Exhale + 27s Rest = 30s
                newLabel = 'Rest & Recover'; // Simplified label
            } else {
                newDurationMs = 15000; // 1s Inhale + 2s Exhale + 12s Rest = 15s
                newLabel = 'Rest & Recover'; // Simplified label
            }

            // Check if session is running and force reset
            if (currentState !== TIMER_STATE.IDLE) {
                resetSession(false);
                setStatusText(`Duration Changed. Session Was Reset. Press 'Start Session' to Begin.`, TIMER_STATE.IDLE);
            }

            // Update internal variables and constants globally
            currentRepDurationMs = newDurationMs;
            currentRestLabel = newLabel;
            PHASE_DURATIONS_MS[TIMER_STATE.ACTIVE_REP] = currentRepDurationMs;
            
            // Recalculate total session duration
            calculateTotalDuration(currentRepDurationMs);
            // Update total time display with new total duration
            totalTimeValue.textContent = formatTime(totalSessionDurationMs);
            // Refresh the progress ring to reflect the updated per-rep segments
            try { updateProgressRing(currentState, Date.now() - (phaseStartTime || Date.now()), PHASE_DURATIONS_MS[currentState]); } catch(e) { /* ignore if not initialized */ }
        };
        
        const initAudio = () => {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) { console.error('Web Audio API not supported:', e); }
            }
        };

        const playTone = (frequency, duration) => {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            // Updated gain to 1.0 for louder sound - Testing at 5
            gainNode.gain.setValueAtTime(5, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        };
        
        let lastPlayedSubPhase = null;
        const playTransitionChime = (subPhase) => {
             if (lastPlayedSubPhase === subPhase) return;
             if (subPhase === SUB_PHASE.INHALE || subPhase === SUB_PHASE.REST) { playTone(440, 0.1); }
             if (subPhase === SUB_PHASE.EXHALE) { playTone(880, 0.2); }
             lastPlayedSubPhase = subPhase;
        };
        
        const updateSetBoxes = () => {
            setProgress.forEach((reps, index) => {
                const box = setBoxes[index];
                const counterElement = box.querySelector('.set-rep-counter');
                const checkmarkElement = box.querySelector('.checkmark-container');
                counterElement.textContent = reps;
                box.classList.remove('bg-gray-500', 'bg-gray-900', 'bg-primary');
                if (reps === 0) {
                    box.classList.add('bg-gray-500'); 
                    checkmarkElement.classList.add('hidden');
                } else if (reps >= 1 && reps <= 4) {
                    box.classList.add('bg-gray-900'); 
                    checkmarkElement.classList.add('hidden');
                } else if (reps === 5) {
                    box.classList.add('bg-primary'); 
                    checkmarkElement.classList.remove('hidden');
                }
            });
        };

        const updateUI = (phase, remainingTimeS) => {
            timerValue.textContent = Math.ceil(remainingTimeS).toString();
            const isCriticalPhase = (phase === SUB_PHASE.EXHALE || phase === SUB_PHASE.INHALE);
            if (isCriticalPhase) {
                pulseRing.classList.remove('hidden');
                pulseRing.classList.add('timer-ring-active');
                timerContainer.classList.add('border-primary');
                timerValue.classList.add('text-primary');
            } else {
                pulseRing.classList.add('hidden');
                pulseRing.classList.remove('timer-ring-active');
                timerContainer.classList.remove('border-primary');
                timerValue.classList.remove('text-primary');
            }
        };

        const finishSession = () => {
            // Finalize and show the success screen (no auto-reset) — waits for user to click "New Session"
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            releaseWakeLock();

            // Replace main instruction with a large SUCCESS label
            setStatusText('Success', TIMER_STATE.IDLE);
            // Enforce a large, prominent style for the success message
            statusText.classList.add('text-5xl', 'font-extrabold', 'h-14');

            // Hide the phase labels when finished
            hidePhaseLabels();

            // Hide the round timer display for a cleaner success screen
            // (timerContainer references the inner circle element used for the large timer)
            if (timerContainer) {
                timerContainer.classList.add('hidden');
                timerContainer.setAttribute('aria-hidden', 'true');
            }

            // Center controls (including New Session) when the timer is hidden
            const controlsWrapper = document.getElementById('controls-wrapper');
            if (controlsWrapper) {
                // Use Tailwind utility classes via classList for centering
                controlsWrapper.classList.add('mx-auto', 'items-center');
            }

            // Ensure all completed sets show their checkmark (updateSetBoxes handles visibility logic)
            updateSetBoxes();

            // Show celebration animation
            showCelebration();

            // Hide regular active controls (pause/reset) and show the "New Session" button
            activeControls.classList.add('hidden');
            const newSessionButton = document.getElementById('new-session-button');
            if (newSessionButton) newSessionButton.classList.remove('hidden');

            // Clear the Time Remaining display on success
            totalTimeValue.textContent = "0:00";

            // Do NOT auto-reset; the UI should remain in the success state until the user clicks New Session
        };

        const resetSession = (isCompleted = false) => {
            // Stop any running animation and clear wake locks
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            releaseWakeLock();

            // Reset runtime state
            currentState = TIMER_STATE.IDLE;
            repCount = 0;
            timeRemainingWhenPaused = 0;
            sessionTimeRemainingWhenPaused = 0; // Reset pause tracking
            setProgress = [0, 0, 0, 0, 0];
            lastPlayedSubPhase = null;
            sessionStartTime = 0;
            
            // Switch to the setup/start screen
            workoutScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            startButton.classList.remove('hidden');
            activeControls.classList.add('hidden');

            // Hide the New Session button if it was visible
            const newSessionButton = document.getElementById('new-session-button');
            if (newSessionButton) newSessionButton.classList.add('hidden');

            // Restore counters visibility (undo finishSession's hiding)
            document.querySelectorAll('.set-rep-counter').forEach(el => {
                el.classList.remove('hidden');
                el.removeAttribute('aria-hidden');
            });

            // Restore the round timer display (unhide the main timer circle)
            if (timerContainer) {
                timerContainer.classList.remove('hidden');
                timerContainer.removeAttribute('aria-hidden');
            }

            // Undo any centering applied for the success state so controls flow normally
            const controlsWrapper = document.getElementById('controls-wrapper');
            if (controlsWrapper) {
                controlsWrapper.classList.remove('mx-auto', 'items-center');
            }

            if (isCompleted) {
                setStatusText('Session<br>Complete!', TIMER_STATE.IDLE);
                showCelebration();
            } else {
                setStatusText('Ready', TIMER_STATE.IDLE);
            }
            
            // Reset UI visuals
            timerValue.textContent = '0';
            pulseRing.classList.add('hidden');
            pulseRing.classList.remove('timer-ring-active');
            timerContainer.classList.remove('border-primary');
            timerValue.classList.remove('text-primary');
            totalTimeValue.textContent = formatTime(totalSessionDurationMs);
            updateSetBoxes();
        };

        // Advance the top-level state machine to the next phase.
        // Note: repCount is incremented elsewhere (when a rep's rest subphase begins). This function
        // determines whether we should go to a long break (after a full set), immediately start another
        // active rep, or end the session when all reps are complete.
        const nextState = () => {
            let nextPhase;
            switch (currentState) {
                case TIMER_STATE.ACTIVE_REP:
                    // Update the current set display using the latest repCount
                    const currentSetIndex = Math.floor((repCount - 1) / 5); 
                    const currentRepInSet = (repCount % 5) || 5;
                    if (currentSetIndex < 5) { setProgress[currentSetIndex] = currentRepInSet; updateSetBoxes(); }

                    // If we've completed all reps, finish the session
                    if (repCount >= TOTAL_REPS) { finishSession(); return; } 
                    // If we just finished a set (every 5 reps), take a long break
                    else if (repCount % 5 === 0) { nextPhase = TIMER_STATE.LONG_BREAK; } 
                    // Otherwise, start the next active rep immediately
                    else { nextPhase = TIMER_STATE.ACTIVE_REP; }
                    break;
                case TIMER_STATE.LONG_BREAK:
                    // After a long break, resume active reps
                    nextPhase = TIMER_STATE.ACTIVE_REP;
                    break;
                case TIMER_STATE.IDLE:
                    // From idle we go to an active rep when starting the session
                    nextPhase = TIMER_STATE.ACTIVE_REP;
                    break;
                default: resetSession(); return;
            }
            currentState = nextPhase;
            phaseStartTime = Date.now();
            lastPlayedSubPhase = null;
            
            if (currentState === TIMER_STATE.LONG_BREAK) {
                const completedSet = repCount / 5; 
                const breakMessage = `Long Rest (Set ${completedSet} Complete)`; 
                setStatusText(breakMessage, currentState);
            } 
            updateUI(currentState, PHASE_DURATIONS_MS[currentState] / 1000); 
        };

        // Update the state shown to the user during an active rep.
        // The active rep is subdivided into: INHALE (first 1s), EXHALE (next 2s), then REST (the remainder).
        // To change inhale/exhale durations, modify the numeric thresholds below (1000ms, 3000ms).
        const updateActiveRepStatus = (elapsedMs) => {
            let subPhase;
            if (elapsedMs < 1000) { // First 1 second: inhale
                subPhase = SUB_PHASE.INHALE;
            } else if (elapsedMs < 3000) { // Next 2 seconds: exhale
                subPhase = SUB_PHASE.EXHALE;
            } else {
                // Rest portion of the rep — we increment repCount once per rep when rest begins
                subPhase = SUB_PHASE.REST;
                if (lastPlayedSubPhase !== SUB_PHASE.REST) {
                    repCount++; 
                    const currentSetIndex = Math.floor((repCount - 1) / 5); 
                    const currentRepInSet = (repCount % 5) || 5;
                    if (currentSetIndex < 5) { setProgress[currentSetIndex] = currentRepInSet; updateSetBoxes(); }
                    
                    // If this rep completed a set, prepare for a long break
                    if (repCount % 5 === 0) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                        if (repCount >= TOTAL_REPS) { finishSession(); return; } 
                        if (repCount < TOTAL_REPS) {
                            currentState = TIMER_STATE.LONG_BREAK;
                            phaseStartTime = Date.now();
                            lastPlayedSubPhase = null;
                            const completedSet = repCount / 5; 
                            const breakMessage = `Long Rest (Set ${completedSet} Complete)`; 
                            setStatusText(breakMessage, currentState);
                            hidePhaseLabels();
                            updateUI(currentState, PHASE_DURATIONS_MS[currentState] / 1000); 
                            requestAnimationFrame(tick);
                            return;
                        }
                    }
                }
            }
            playTransitionChime(subPhase);
            let displayText;
            if (subPhase === SUB_PHASE.EXHALE) { displayText = EXHALE_INSTRUCTIONS; } 
            else if (subPhase === SUB_PHASE.REST) { displayText = currentRestLabel; } 
            else { displayText = SUB_PHASE.INHALE; }

            // Render the colored phase labels with the current subphase bolded
            renderPhaseLabels(subPhase);
            setStatusText(displayText, subPhase);
        };

        const tick = () => {
            if (currentState === TIMER_STATE.IDLE || currentState === TIMER_STATE.PAUSED) return;
            const now = Date.now();
            const elapsed = now - phaseStartTime;
            const duration = PHASE_DURATIONS_MS[currentState];
            let remaining = duration - elapsed;
            
            if (remaining <= 0) { nextState(); } 
            else {
                updateUI(currentState, remaining / 1000);
                if (currentState === TIMER_STATE.ACTIVE_REP) { updateActiveRepStatus(elapsed); }
                // Update the visual progress ring and sweep indicator
                updateProgressRing(currentState, elapsed, duration);
            }
            
            // --- Corrected Total Time Calculation ---
            const totalElapsed = now - sessionStartTime;
            let totalRemaining = totalSessionDurationMs - totalElapsed;
            if (totalRemaining < 0) totalRemaining = 0;
            // totalTimeValue.textContent = formatTime(totalRemaining); // Hidden for now

            animationFrameId = requestAnimationFrame(tick);
        };

        // Start a new session: set up audio, request wake lock (keeps the screen awake), switch screens,
        // and begin the animation loop which drives the timer.
        const startSession = () => {
            if (currentState !== TIMER_STATE.IDLE) return;
            initAudio();          // prepare sound (if available)
            requestWakeLock();    // try to keep the screen awake while session is active
            startScreen.classList.add('hidden');
            workoutScreen.classList.remove('hidden');
            activeControls.classList.remove('hidden');
            pauseResumeButton.textContent = 'Pause';
            pauseResumeButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            pauseResumeButton.classList.add('bg-red-600', 'hover:bg-red-700');
            sessionStartTime = Date.now(); 
            nextState(); 
            animationFrameId = requestAnimationFrame(tick);
        };

        // Pause the running timer: stop the animation loop, release the wake lock, and save
        // the current remaining times so we can resume exactly where we left off.
        const pauseTimer = () => {
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            releaseWakeLock();
            const elapsedSincePhaseStart = Date.now() - phaseStartTime;
            const duration = PHASE_DURATIONS_MS[currentState];
            timeRemainingWhenPaused = duration - elapsedSincePhaseStart;
            
            // Capture current Total Time Remaining state for Resume
            sessionTimeRemainingWhenPaused = totalSessionDurationMs - (Date.now() - sessionStartTime);

            activeStateBeforePause = currentState; 
            currentState = TIMER_STATE.PAUSED;
            lastPlayedSubPhase = null; 
            pauseResumeButton.textContent = 'Resume';
            pauseResumeButton.classList.remove('bg-red-600', 'hover:bg-red-700');
            pauseResumeButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            setStatusText(PAUSE_INSTRUCTIONS, TIMER_STATE.PAUSED);
            hidePhaseLabels();
            updateUI(currentState, timeRemainingWhenPaused / 1000);
            
            // Ensure display is static and correct
            if (sessionTimeRemainingWhenPaused < 0) sessionTimeRemainingWhenPaused = 0;
            totalTimeValue.textContent = formatTime(sessionTimeRemainingWhenPaused);
        };

        // Resume a paused session: restore the saved times, re-request wake lock, and continue ticking.
        const resumeTimer = () => {
            currentState = activeStateBeforePause; 
            requestWakeLock(); 
            const duration = PHASE_DURATIONS_MS[currentState];
            phaseStartTime = Date.now() - (duration - timeRemainingWhenPaused); 
            timeRemainingWhenPaused = 0; 
            
            // Restore Session Start Time from saved Remaining Time
            // New Start Time = Now - (TotalDuration - Remaining)
            sessionStartTime = Date.now() - (totalSessionDurationMs - sessionTimeRemainingWhenPaused);

            pauseResumeButton.textContent = 'Pause';
            pauseResumeButton.classList.add('bg-red-600', 'hover:bg-red-700');
            pauseResumeButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            
            if (currentState === TIMER_STATE.LONG_BREAK) {
                 const completedSet = repCount / 5; 
                 const breakMessage = `Long Rest (Set ${completedSet} Complete)`; 
                 setStatusText(breakMessage, currentState);
            } else if (currentState === TIMER_STATE.ACTIVE_REP) {
                 const elapsed = Date.now() - phaseStartTime;
                 updateActiveRepStatus(elapsed);
            }
            animationFrameId = requestAnimationFrame(tick);
            updateUI(currentState, (duration - (Date.now() - phaseStartTime)) / 1000);
        };

        startButton.addEventListener('click', () => { if (currentState === TIMER_STATE.IDLE) startSession(); });
        pauseResumeButton.addEventListener('click', () => {
            if (currentState === TIMER_STATE.PAUSED) resumeTimer();
            else if (currentState !== TIMER_STATE.IDLE) pauseTimer();
        });
        resetButton.addEventListener('click', () => {
            if (currentState !== TIMER_STATE.IDLE) {
                wasRunningBeforeModal = (currentState !== TIMER_STATE.PAUSED);
                if (wasRunningBeforeModal) pauseTimer(); 
                openResetModal();
            }
        });
        confirmResetButton.addEventListener('click', () => { resetSession(false); closeResetModal(); wasRunningBeforeModal = false; });
        cancelResetButton.addEventListener('click', () => { closeResetModal(); if (wasRunningBeforeModal) resumeTimer(); wasRunningBeforeModal = false; });

        // Handle the New Session button (appears only after successful completion)
        const newSessionButton = document.getElementById('new-session-button');
        if (newSessionButton) {
            newSessionButton.addEventListener('click', () => {
                // Reset back to the start/setup state when user requests a new session
                resetSession(false);
            });
        }

        window.handleRestDurationChange('15'); 
        setStatusText(INITIAL_INSTRUCTIONS, TIMER_STATE.IDLE);
        updateUI(TIMER_STATE.IDLE, 0);
        updateSetBoxes();
        // Initialize visual ring to idle state
        updateProgressRing(TIMER_STATE.IDLE, 0, 1); 
    </script>
</body>
</html>